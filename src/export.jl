
using CSV, LightXML

export exportCSVRules

struct UnsupportedSignalTypeError <: Exception
    cell_type::String
    behavior_name::String
    signal_name::String
    signal_type::String
end

function Base.showerror(io::IO, err::UnsupportedSignalTypeError)
    println(io, """
    Unsupported signal type `$(err.signal_type)` found in XML for cell type $(err.cell_type) in behavior $(err.behavior_name) and signal $(err.signal_name).
    Supported signal types are "partial_hill", "hill", "identity", "linear", and "heaviside". This is case-insensitive.
    """)
end

"""
    exportCSVRules(path_to_csv::AbstractString, path_to_xml::AbstractString; force::Bool=false)

Export the rules from the XML file at `path_to_xml` to the CSV file at `path_to_csv`.

If `force` is set to `true`, the function will overwrite the existing CSV file at `path_to_csv` if it exists.
Note: this is not the inverse of [`writeXMLRules`](@ref) as `writeXMLRules` discards comments in the original CSV and `exportCSVRules` adds comments to the exported CSV file.
"""
function exportCSVRules(path_to_csv::AbstractString, path_to_xml::AbstractString; force::Bool=false)
    @assert splitext(path_to_csv)[2] == ".csv" "The path to the CSV file must have a .csv extension. Got $(path_to_csv)"
    @assert force || !isfile(path_to_csv) "The file $(path_to_csv) already exists. Use exportCSVRules(...; force=true) to overwrite it."
    @assert splitext(path_to_xml)[2] == ".xml" "The path to the XML file must have a .xml extension. Got $(path_to_xml)"
    @assert isfile(path_to_xml) "The path to the XML file must exist. $(path_to_xml) is not a file."

    xml_doc = parse_file(path_to_xml)
    xml_root = root(xml_doc)
    io = open(path_to_csv, "w")

    println(io, "// XML Rules Export\n")
    println(io, "// This file was generated by PhysiCellXMLRules.jl\n")
    println(io, "// README:")
    println(io, "/" ^ 130)
    println(io, "// cell_type,(s₁) signal (s₂),response (s₃),behavior,max_response,p₁,p₂,applies_to_dead")
    println(io, "// s₁: if 'decreasing', then as the signal decreases, the behavior <response>; (s₁) omitted if 'increasing'")
    println(io, "// s₂: if 'from <value>', then the signal affects the behavior from <value> onwards (depending on s₁); omitted implies 'from 0.0'")
    println(io, "// s₃: the type of function (one of 'partial_hill', 'hill', 'identity', 'linear', 'heaviside'); (s₃) omitted if 'partial_hill'")
    println(io, "// pᵢ: the parameters for the function:")
    println(io, "//   - half_max and hill_power for partial_hill and hill")
    println(io, "//   - none for identity; leave both empty, i.e. '<max_response>,,,<applies_to_dead>'")
    println(io, "//   - signal_min and signal_max for linear")
    println(io, "//   - threshold for heaviside; leave p₂ empty, i.e. '...,<threshold>,,<applies_to_dead>'")
    println(io, "/" ^ 130 * "\n\n")

    for behavior_ruleset in get_elements_by_tagname(xml_root, "behavior_ruleset")
        exportCellToCSV(io, behavior_ruleset)
    end
    close(io)
    free(xml_doc)
end

function exportCellToCSV(io::IO, behavior_ruleset::XMLElement)
    cell_type = attribute(behavior_ruleset, "name")
    println(io, "// $cell_type")
    for behavior in get_elements_by_tagname(behavior_ruleset, "behavior")
        exportBehaviorToCSV(io, cell_type, behavior)
    end
    println(io, "")
end

function exportBehaviorToCSV(io::IO, cell_type::AbstractString, behavior::XMLElement)
    behavior_name = attribute(behavior, "name")
    println(io, "// └─$behavior_name")
    exportMediatorToCSV(io, cell_type, behavior, behavior_name, 2)
end

function exportMediatorToCSV(io::IO, cell_type::AbstractString, behavior::XMLElement, behavior_name::AbstractString, indent::Int, max_response::Union{Nothing,AbstractString}=nothing; is_top_level::Bool=true)
    type_element = find_element(behavior, "type")
    base_value_element = find_element(behavior, "base_value")
    base_value = isnothing(base_value_element) ? nothing : content(base_value_element)
    mediator_element = find_element(behavior, "mediator")
    mediator = isnothing(mediator_element) ? "decreasing_dominant" : content(mediator_element)
    if is_top_level
        type = (isnothing(type_element) ? "setter" : content(type_element))
        line = "// $("  " ^ (indent-1))└─$type" * (isnothing(base_value) ? "" : " with base value $base_value") * " using a $mediator mediator"
        next_indent = indent
    else
        line = "// $("  " ^ (indent))└─mediate using a $mediator mediator"
        next_indent = indent + 1
    end
    println(io, line)
    decreasing_signals_element = find_element(behavior, "decreasing_signals")
    if !isnothing(decreasing_signals_element)
        max_response_element = find_element(decreasing_signals_element, "max_response")
        max_decreasing_response = isnothing(max_response_element) ? max_response : content(max_response_element)
        aggregator_element = find_element(decreasing_signals_element, "aggregator")
        aggregator = isnothing(aggregator_element) ? "multivariate_hill" : content(aggregator_element)
        middle_str = isempty(something(max_decreasing_response, "")) ? "" : " to $max_decreasing_response"
        println(io, "// $("  " ^ (next_indent))└─decreasing", middle_str, " using a $aggregator aggregator")
        exportAggregatorToCSV(io, cell_type, behavior_name, max_decreasing_response, decreasing_signals_element, :decreases, next_indent+1)
    end
    increasing_signals_element = find_element(behavior, "increasing_signals")
    if !isnothing(increasing_signals_element)
        max_response_element = find_element(increasing_signals_element, "max_response")
        max_increasing_response = isnothing(max_response_element) ? max_response : content(max_response_element)
        aggregator_element = find_element(increasing_signals_element, "aggregator")
        aggregator = isnothing(aggregator_element) ? "multivariate_hill" : content(aggregator_element)
        middle_str = isempty(something(max_increasing_response, "")) ? "" : " to $max_increasing_response"
        println(io, "// $("  " ^ (next_indent))└─increasing", middle_str, " using a $aggregator aggregator")
        exportAggregatorToCSV(io, cell_type, behavior_name, max_increasing_response, increasing_signals_element, :increases, next_indent+1)
    end
end

function exportAggregatorToCSV(io::IO, cell_type::AbstractString, behavior_name::AbstractString, max_response::AbstractString, signals_element::XMLElement, response::Symbol, indent::Int)
    for signal in get_elements_by_tagname(signals_element, "signal")

        signal_type = something(attribute(signal, "type"), "partial_hill") |> lowercase

        if signal_type == "mediator"
            return exportMediatorToCSV(io, cell_type, signal, behavior_name, indent, max_response; is_top_level=false)
        elseif signal_type == "aggregator"
            return exportAggregatorToCSV(io, cell_type, behavior_name, max_response, signal, response, indent)
        end

        signal_name = attribute(signal, "name")

        #! if here, then it is an elementary signal
        if !(signal_type in ["partial_hill", "hill", "identity", "linear", "heaviside"])
            throw(UnsupportedSignalTypeError(cell_type, behavior_name, signal_name, signal_type))
        end

        if signal_type == "partial_hill"
            exportPartialHillSignalToCSV(io, cell_type, signal, signal_name, response, behavior_name, max_response)
        elseif signal_type == "hill"
            exportHillSignalToCSV(io, cell_type, signal, signal_name, response, behavior_name, max_response)
        elseif signal_type == "identity"
            exportIdentitySignalToCSV(io, cell_type, signal, signal_name, response, behavior_name, max_response)
        elseif signal_type == "linear"
            exportLinearSignalToCSV(io, cell_type, signal, signal_name, response, behavior_name, max_response)
        elseif signal_type == "heaviside"
            exportHeavisideSignalToCSV(io, cell_type, signal, signal_name, response, behavior_name, max_response)
        end
    end
end

function exportAggregatorToCSV(io::IO, cell_type::AbstractString, behavior_name::AbstractString, ::Nothing, signals_element::XMLElement, response::Symbol, indent::Int)
    @info """
    The XML-based rules can omit a top-level max response, using the base parameter value as the max response instead. However, the CSV export format requires a max_response for each row, so this row will be exported with an empty max_response value.
    See warnings below for specific instances.
    """ maxlog=1
    @warn "An aggregator for cell type $(cell_type) in behavior $(behavior_name) with response $(response) has no max_response specified. See info message above for details."
    exportAggregatorToCSV(io, cell_type, behavior_name, "", signals_element, response, indent)
end

function exportPartialHillSignalToCSV(io::IO, cell_type::AbstractString, signal::XMLElement, signal_name::String, response::Symbol, behavior_name::AbstractString, max_response::AbstractString)
    half_max = content(find_element(signal, "half_max"))
    hill_power = content(find_element(signal, "hill_power"))
    applies_to_dead = content(find_element(signal, "applies_to_dead"))
    signal_name = parseSignalReference(signal_name, signal)
    row = (cell_type, signal_name, response, behavior_name, max_response, half_max, hill_power, _booleanToBinary(applies_to_dead))
    println(io, join(row, ","))
end

function exportHillSignalToCSV(io::IO, cell_type::AbstractString, signal::XMLElement, signal_name::String, response::Symbol, behavior_name::AbstractString, max_response::AbstractString)
    half_max = content(find_element(signal, "half_max"))
    hill_power = content(find_element(signal, "hill_power"))
    applies_to_dead = content(find_element(signal, "applies_to_dead"))
    signal_name = parseSignalReference(signal_name, signal)
    row = (cell_type, signal_name, "$response (hill)", behavior_name, max_response, half_max, hill_power, _booleanToBinary(applies_to_dead))
    println(io, join(row, ","))
end

function exportIdentitySignalToCSV(io::IO, cell_type::AbstractString, signal::XMLElement, signal_name::String, response::Symbol, behavior_name::AbstractString, max_response::AbstractString)
    applies_to_dead = content(find_element(signal, "applies_to_dead"))
    signal_name = parseSignalReference(signal_name, signal)
    row = (cell_type, signal_name, "$response (identity)", behavior_name, max_response, "", "", _booleanToBinary(applies_to_dead))
    println(io, join(row, ","))
end

function exportLinearSignalToCSV(io::IO, cell_type::AbstractString, signal::XMLElement, signal_name::String, response::Symbol, behavior_name::AbstractString, max_response::AbstractString)
    signal_min = content(find_element(signal, "signal_min"))
    signal_max = content(find_element(signal, "signal_max"))
    applies_to_dead = content(find_element(signal, "applies_to_dead"))
    signal_name = parseDirectionOfAbsoluteSignal(signal_name, signal)
    row = (cell_type, signal_name, "$response (linear)", behavior_name, max_response, signal_min, signal_max, _booleanToBinary(applies_to_dead))
    println(io, join(row, ","))
end

function exportHeavisideSignalToCSV(io::IO, cell_type::AbstractString, signal::XMLElement, signal_name::String, response::Symbol, behavior_name::AbstractString, max_response::AbstractString)
    threshold = content(find_element(signal, "threshold"))
    applies_to_dead = content(find_element(signal, "applies_to_dead"))
    signal_name = parseDirectionOfAbsoluteSignal(signal_name, signal)
    row = (cell_type, signal_name, "$response (heaviside)", behavior_name, max_response, threshold, "", _booleanToBinary(applies_to_dead))
    println(io, join(row, ","))
end

function parseSignalReference(signal_name::AbstractString, signal::XMLElement)
    reference = SignalReference(signal)
    if isnothing(reference)
        return signal_name
    end
    str_start = reference.type == "increasing" ? "" : "(decreasing) "
    return "$str_start$(signal_name) (from $(reference.value))"
end

function parseDirectionOfAbsoluteSignal(signal_name::AbstractString, signal::XMLElement)
    type_element = find_element(signal, "type")
    if isnothing(type_element) || content(type_element) == "increasing"
        return signal_name
    end
    return "(decreasing) $(signal_name)"
end